# This is Jordan's eye
### HY

## 概述

视觉识别的目标是通过用摄像头以固定时间间隔对棋盘进行拍摄，并将当前图片
与前一状态进行对比从而得到玩家落子的位置。

## 图像获取

使用了微视的工业用摄像头，用在官方给出的sdk基础上用C#二次开发
了一个可以以一定时间间隔拍摄图像的后台程序，将得到的照片保存
在了本项目目录下的camera文件夹中

## 算法实现

### 实现目标
输出获取到的图像，在确定发生玩家落子的条件下，用向量形式输出玩家落子的位置

### 初始想法

先抠出图片中的棋盘区域，然后将棋盘区域分割为9 * 9
个子区域，然后对每个子区域中的像素点进行加和平均，并且设定两个阈值，当大于上限阈值时判定为白子，小于下限阈值时，判定为黑子，
得到描述局势的矩阵，将先后两次矩阵做差，得到落子位置(返回差矩阵上非零数的行和列)

### 初始想法产生的问题

由于实际拍摄的照片中，会因为现实中的灯光或者遮盖物以及棋盘本身的反光，导致棋盘的每个区域的光照强度有较大差异，
因此使用的固定的两个阈值会难以分辨落了白子和未落子这两种情况，因为在反光或者部分曝光过度的区域，
算出来的像素点加和平均完全有可能超过上限阈值

### 解决思路

因为区域亮度不平衡主要影响在了识别落了白子和未落子这两种情况，因此
解决这个问题的关键在于将三值化问题转换为二值化问题

### 解决思路

直接比对当前图片与前一张图片的差异，用一种类似于找不同的方法，抠出改变了的区域，即落子区域，
因为落子区域已经确定落了子，因而，处理落子的情况中，就只需要考虑所落的子为黑子还是白子，
而这一问题则是一个二值化问题，只需要确定一个可靠的阈值就可以了，因为黑子和白子区域得到像素加和平均
差异很大，因此可以很容易分出

### 具体解决方法

用了opencv中的中值模糊以及自适应阈值的二值化这两个方法，
首先将当前图片与前一状态图片都进行中值模糊以此来降低噪声，然后将两张图片做自适应阈值二值化，得到
各自的线框图，然后将两张线框图做异或操作取出不同区域，并对结果再一次做中值模糊降噪，于是就
得到了当前落子的位置，在根据这一位置信息，与原图进行比对，得到落子方以及落子的位置

### 实现的接口说明
- 上述的图像处理过程都放在了opencv_process.py文件中



然后在读取图片获取palyer输入的过程中，我用了一个简单的忙等待解决这一问题，就是通过以固定时间间隔不断地读取当前图片
将其与前一状态进行对比，如果没有找出落子区域，则继续忙等待，若找到落子区域，如果落子的为机器人，
则更新状态，若落子的为人，则返回落子位置，并更新状态。